import { Agent } from '../agent';
import { getMarketData, MarketData } from '@workspace/data-providers/polygon';
import { fetchNewsScores } from '@workspace/data-providers/news';
import { canEnterTrade, sizePosition } from '@workspace/risk/hold';

/** Signal generated by MomentumAgent */
export interface MomentumSignal {
  symbol: string;
  score: number;
  risk: number;
  timestamp: number;
}

/**
 * MomentumAgent combines market momentum with sentiment and macro data.
 */
export class MomentumAgent implements Agent<MarketData[], MomentumSignal> {
  name = 'MomentumAgent';
  private signals: MomentumSignal[] = [];

  async onEvent(evt: MarketData[]): Promise<void> {
    const bySymbol: Record<string, MarketData[]> = {};
    for (const m of evt) {
      (bySymbol[m.symbol] ||= []).push(m);
    }
    const news = await fetchNewsScores(Object.keys(bySymbol));
    const now = Date.now();

    for (const symbol of Object.keys(bySymbol)) {
      const data = bySymbol[symbol];
      data.sort((a, b) => a.timestamp - b.timestamp);
      const first = data[0];
      const last = data[data.length - 1];
      const momentum = (last.close - first.close) / first.close; // simple slope
      const sentiment = news[symbol]?.sentiment ?? 0;
      const health = news[symbol]?.macro ?? 0;
      const score = momentum * 0.6 + sentiment * 0.3 + health * 0.1;

      if (!canEnterTrade(new Date(last.timestamp))) continue;
      const risk = sizePosition(score, 1); // sizing relative weight

      this.signals.push({
        symbol,
        score,
        risk,
        timestamp: now,
      });
    }
    // Keep only top 5 signals
    this.signals.sort((a, b) => b.score - a.score);
    this.signals = this.signals.slice(0, 5);
  }

  async getSignals(): Promise<MomentumSignal[]> {
    return this.signals;
  }
}
